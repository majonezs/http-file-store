{
  "name": "Http-file-store",
  "tagline": "HTTP server to store files",
  "body": "# http-file-store\r\n\r\nServer and api to manipulates files over HTTP.\r\n\r\n# binary\r\n\r\n`http-file-store` is a stand alone web server which provides\r\nan api to manipulate a file system over HTTP.\r\n\r\n### install\r\n```\r\nnpm i -g mh-cbon/http-file-store\r\n```\r\n\r\n### usage\r\n```\r\nhttp-file-store 1.0.0\r\n  Server and api to manipulate a file system over http\r\n\r\nUsage\r\n\r\n  http-file-store --config=/path/to/config.json\r\n\r\nOptions\r\n\r\n  --config  | -c   Path to the JSON configuration file\r\n  --port    | -p   Port of the CLEAR http server, if no configuration is provided.\r\n  --verbose | -v   Enable verbosity pass in the module list to debug.\r\n\r\nConfig\r\n\r\n  The configuration is a plain json object describing several options to\r\n  apply to your instance of http-file-store.\r\n\r\n  {\r\n    \"url_base\": \"/base/url/to/serve/files/ending/with/a/slash\",\r\n    \"upload_path\": \"/path/to/temp/uploaded/files\",\r\n    \"show_absolute_path\": true|false,\r\n    \"allow_overwrite\": true|false,\r\n    \"allow_delete\": true|false,\r\n    \"configurable_alias\": true|false,\r\n    \"aliases\": {\r\n      \"alias_name\": \"/path/to/the/directory/to/read/write/files\"\r\n    },\r\n    \"ssl\": {\r\n      \"port\": \"a number, or null for a random port\",\r\n      \"host\": \"a host value to listen for https requests\",\r\n      \"key\": \"a path to an SSL key\",\r\n      \"ca\": \"a path to the SSL CA file\",\r\n      \"cert\": \"a path to the SSL cert file\"\r\n    },\r\n    \"clear\": {\r\n      \"port\": \"a number, or null for a random port\",\r\n      \"host\": \"a host value to listen for http requests\"\r\n    },\r\n    \"cors\": {\r\n      \"origin\": \"*\",\r\n      \"credentials\": \"true|false\",\r\n      \"methods\": ['GET', 'PUT', 'POST'],\r\n      \"allowedHeaders\": ['Content-Type', 'Authorization'],\r\n      \"exposedHeaders\": ['Content-Range', 'X-Content-Range'],\r\n      \"maxAge\": 600\r\n    }\r\n  }\r\n```\r\n\r\n# bin\r\n\r\n### Configuration\r\n\r\nThe configuration is set via a `config.json` file defined from the command line invocation with `-c|--config` parameter.\r\n\r\n#### Setting the root paths to serve\r\n\r\nTo set the root path of the file system managed via the API, you can define those options:\r\n\r\n##### Set base option\r\n\r\n`base: \"/path/to/serve/\"` will define a unique file system entry point to serve.\r\n\r\nNote: Internally it is transformed into an alias such `{alias:{\"\":\"/path/\"}}`\r\n\r\nNote2: `base` and `alias` directives are exclusive.\r\n\r\n##### Define multiple alias\r\n\r\nAlternatively to the `base` directive, you can define an `alias` object of `path` to serve, such\r\n\r\n```json\r\nalias: {\r\n  \"name\": \"path\",\r\n  \"name1\": \"path1\",\r\n}\r\n```\r\n\r\nDoing so enable you to serve multiple root directories.\r\n\r\nTo fetch the list of aliases, you can query `/`.\r\n\r\nTo fetch the content of an alias, you can query `/my_alias/` and so on.\r\n\r\n#### Other noticeable options\r\n\r\n##### allow_delete: true\r\n\r\nEnable a new route to delete files and directories.\r\n\r\n##### show_absolute_path: true\r\n\r\nAdd a property to the directory listing which provides the full path of the item on the remote system.\r\n\r\n##### allow_overwrite: true\r\n\r\nEnable file overwrite capabilities.\r\n\r\n##### configurable_alias: true\r\n\r\nEnable a new routes to manage configuration aliases from the API.\r\n\r\n##### upload_path: \"/path/to/save/tmp/uploaded/files\"\r\n\r\nDefines the path of the directory to write temporary uploaded files.\r\n\r\n##### url_base: \"/base/url/of/api/\"\r\n\r\nDefines the base url from which the API is served. Must end with a `/`.\r\n\r\n### Pre defined routes without alias\r\n\r\n##### GET /\r\n\r\nRead root directory content and return it as a JSON object.\r\n\r\n##### GET /:path\r\n\r\nRead a path, if it is a directory, returns its content as a JSON object. If its a file, stream its content. Use `download=1` to force file download.\r\n\r\n##### POST /:store_path\r\n\r\nProvide a field `file` to write a file onto the system.\r\nUse `overwrite=1` to overwrite an existing file.\r\n\r\nProvide `name` to create a directory.\r\n\r\n##### DELETE /:path_to_delete\r\n\r\nUnlink a file or a directory from the file system. Use `recursive=1` to recursively delete a directory.\r\n\r\n### Pre defined routes with aliases\r\n\r\n##### GET /\r\n\r\nReturns the list of `aliases` as a directory listing.\r\n\r\n##### GET /:alias/:path\r\n\r\nRead a `path` within given `alias`, if it is a directory, returns its content as a JSON object. If its a file, stream its content. Use `download=1` to force file download.\r\n\r\n##### POST /:alias/:store_path\r\n\r\nProvide a field `file` to write a file onto the system.\r\nUse `overwrite=1` to overwrite an existing file.\r\n\r\nProvide `name` to create a directory.\r\n\r\n##### DELETE /:alias/:path_to_delete\r\n\r\nUnlink a `file` or a `directory` within given `alias`. Use `recursive=1` to recursively delete a directory.\r\n\r\n# express handlers\r\n\r\n`http-file-store` can also be consumed as a module of your project.\r\nIt provides multiple handlers to use with an express application.\r\n\r\n### Example\r\n\r\n```js\r\n\r\nvar fileStore = require('http-file-store');\r\nvar upload    = multer({ dest: config.upload_path });\r\nvar app       = express();\r\n\r\n// list aliases root directories\r\n// but it returns JSON responses for directories.\r\napp.get(config.url_base + \"\", fileStore.root(config));\r\n\r\n// provide a read access, much like serve-static,\r\n// but it returns JSON responses for directories.\r\napp.get(config.url_base + \":alias/*\", fileStore.read(config));\r\n\r\n// provide write access, using multer to manage file uploads.\r\napp.post(config.url_base + \":alias/*\", upload.single('file'), fileStore.write(config));\r\n\r\n// provide delete access, using multer to manage file uploads.\r\napp.delete(config.url_base + \":alias/*\", fileStore.unlink(config));\r\n\r\n// provides aliases management routes\r\nif (config.configurable_alias) {\r\n  // list alias object from the config\r\n  app.get(config.url_base + \"aliases\", fileStore.aliases.get(config));\r\n\r\n  // add an alias to the configuration\r\n  app.post(config.url_base + \"aliases/add/\",\r\n    bodyParser.urlencoded({extended: !true}), fileStore.aliases.add(config, configPath));\r\n\r\n  // remove an alias from the configuration\r\n  app.post(config.url_base + \"aliases/remove/\",\r\n    bodyParser.urlencoded({extended: !true}), fileStore.aliases.remove(config));\r\n}\r\n\r\n```\r\n\r\n# http api\r\n\r\n`http-file-store` can manipulate files based on url path of the query.\r\n\r\n### Read\r\n\r\n##### A file\r\n\r\nGiven a route mounted on `/read`, and a file `some.txt`\r\non the root of an `empty` aliased directory (`{alias:{\"\":\"/path/\"}}`):\r\n\r\n ```js\r\n request(app)\r\n   .get('/read/some.txt')\r\n   .expect('Content-Type', /text/)\r\n   .expect(200, /content/)\r\n   .end(done)\r\n ```\r\n\r\nWhen the target path provided within the url path is recognized as a `file`,\r\nthe content is streamed to the client.\r\n\r\nYou may force file download by sending an extra __query__ parameter with the GET request,\r\n\r\n```js\r\nrequest(app)\r\n  .get('/read/some.txt?download=1')\r\n  .expect('Content-Disposition', /attachment/)\r\n  .expect(200)\r\n```\r\n\r\n##### A directory\r\n\r\nWhen the target path provided within the url path is recognized as a `directory`,\r\nthe listing of the directory is returned as a JSON object such:\r\n\r\n  ```js\r\n  [\r\n    {\r\n      name:   f,\r\n      type:   stats.isFile() ? 'file' : 'dir',\r\n      size:   stats.size,\r\n      mime:   mime.lookup(path.join(filePath, f)) || 'application/octet-stream',\r\n      atime:  stats.atime,\r\n      mtime:  stats.mtime,\r\n      ctime:  stats.ctime,\r\n      birthtime: stats.birthtime,\r\n      // only when config.show_absolute_path is true\r\n      absolute_path: path.resolve(path.join(filePath, f))\r\n    }\r\n  ]\r\n  ```\r\n\r\n### Write\r\n\r\nGiven a route mounted on `/write`, and a file `other.txt` to write\r\non the root of an `empty` aliased directory (`{alias:{\"\":\"/path/\"}}`):\r\n\r\n```js\r\nrequest(app)\r\n  .post('/write/')\r\n  .attach('file', 'other.txt')\r\n  .expect(200)\r\n```\r\n\r\nOn successful write, the route handler will return the new listing of the\r\ndirectory, much like a read access:\r\n\r\n```js\r\n[\r\n  {\r\n    name:   f,\r\n    type:   stats.isFile() ? 'file' : 'dir',\r\n    size:   stats.size,\r\n    mime:   mime.lookup(path.join(filePath, f)) || 'application/octet-stream',\r\n    atime:  stats.atime,\r\n    mtime:  stats.mtime,\r\n    ctime:  stats.ctime,\r\n    birthtime: stats.birthtime,\r\n    // only if config.show_absolute_path is true\r\n    absolute_path: path.resolve(path.join(filePath, f))\r\n  }\r\n]\r\n```\r\n\r\n##### Overwriting\r\n\r\nWhen `config.json` file is configured to allow overwrite,\r\n\r\n```json\r\n{\r\n  \"allow_overwrite\": true,\r\n}\r\n```\r\n\r\nYou may overwrite a file by sending an extra __query__ parameter with the POST request,\r\n\r\n```js\r\nrequest(app)\r\n  .post('/write/?overwrite=1')\r\n  .attach('file', 'other.txt')\r\n  .expect(200)\r\n```\r\n\r\n### Delete\r\n\r\n##### A file\r\n\r\nGiven a route mounted on `/delete`, and a file `some.txt` to delete\r\non the root of an `empty` aliased directory (`{alias:{\"\":\"/path/\"}}`):\r\n\r\n```js\r\nrequest(app)\r\n  .delete('/delete/some.txt')\r\n  .expect(200)\r\n```\r\n\r\nOn successful delete, the route handler will return the new listing of the\r\ndirectory, much like a read access:\r\n\r\n```js\r\n[\r\n  {\r\n    name:   f,\r\n    type:   stats.isFile() ? 'file' : 'dir',\r\n    size:   stats.size,\r\n    mime:   mime.lookup(path.join(filePath, f)) || 'application/octet-stream',\r\n    atime:  stats.atime,\r\n    mtime:  stats.mtime,\r\n    ctime:  stats.ctime,\r\n    birthtime: stats.birthtime,\r\n    // only if config.show_absolute_path is true\r\n    absolute_path: path.resolve(path.join(filePath, f))\r\n  }\r\n]\r\n```\r\n\r\n##### A directory\r\n\r\nYou can delete a directory too, if the directory is not empty,\r\nyou shall send an extra query parameter\r\n`recursive=1` to recursively delete a directory.\r\n\r\n```js\r\nrequest(app)\r\n  .delete('/delete/other/?recursive=1')\r\n  .expect(200)\r\n```\r\n\r\nOn successful delete, the route handler will return the new listing of the\r\ndirectory, much like a read access:\r\n\r\n```js\r\n[\r\n  {\r\n    name:   f,\r\n    type:   stats.isFile() ? 'file' : 'dir',\r\n    size:   stats.size,\r\n    mime:   mime.lookup(path.join(filePath, f)) || 'application/octet-stream',\r\n    atime:  stats.atime,\r\n    mtime:  stats.mtime,\r\n    ctime:  stats.ctime,\r\n    birthtime: stats.birthtime,\r\n    // only if config.show_absolute_path is true\r\n    absolute_path: path.resolve(path.join(filePath, f))\r\n  }\r\n]\r\n```\r\n\r\n### Configure aliases\r\n\r\nWhen `config.configurable_alias` is true, the binary will add new routes to\r\nget / add / remove aliases.\r\n\r\n##### Read\r\n\r\nGiven a route mounted on `/`, retrieve aliases object as of a directory listing\r\n\r\n```js\r\nrequest(app)\r\n  .get('/')\r\n  .expect('Content-Type', /json/)\r\n  .expect(200)\r\n```\r\n\r\nResponse will be such\r\n\r\n```js\r\n[\r\n  {\r\n    name:   aliasName,\r\n    type:   'alias',\r\n    size:   0\r\n    mime:   'application/octet-stream',\r\n    atime:  0,\r\n    mtime:  0,\r\n    ctime:  0,\r\n    birthtime: 0,\r\n    // only if config.show_absolute_path is true\r\n    absolute_path: path.resolve(process.cwd(), config.aliases[alias])\r\n  }\r\n]\r\n```\r\n\r\n##### Get\r\n\r\nGiven a route mounted on `/aliases`, retrieve aliases object\r\n\r\n```js\r\nrequest(app)\r\n  .get('/aliases/')\r\n  .expect('Content-Type', /json/)\r\n  .expect(200)\r\n```\r\n\r\nResponse will be such\r\n\r\n```js\r\n{\r\n  \"name\": \"/path/\",\r\n  \"name1\": \"/path1/\",\r\n}\r\n```\r\n\r\n##### Add\r\n\r\nGiven a route mounted on `/add`, you may add a new `alias` to the current\r\nconfiguration by doing a POST request with an `alias` and a `path` fields.\r\n\r\n```js\r\nrequest(app)\r\n  .post('/add/')\r\n  .field('alias', 'name')\r\n  .field('path', 'path of the alias')\r\n  .expect(200)\r\n```\r\n\r\nYou may persist the new configuration by sending an extra __query__ parameter with the POST request,\r\n\r\n```js\r\nrequest(app)\r\n  .post('/add/?persist=1')\r\n  .field('alias', 'name')\r\n  .field('path', 'path of the alias')\r\n  .expect(200)\r\n```\r\n\r\nReturns the new list of aliases as a directory listing\r\n\r\n```js\r\n{\r\n  \"name\": \"/path/\",\r\n  \"name1\": \"/path1/\",\r\n}\r\n```\r\n\r\n##### Remove\r\n\r\nGiven a route mounted on `/remove`, you may remove an `alias` of the current\r\nconfiguration by doing a POST request with an `alias` fields.\r\n\r\n```js\r\nrequest(app)\r\n  .post('/remove/')\r\n  .field('alias', 'name')\r\n  .expect(200)\r\n```\r\n\r\nYou may persist the new configuration by sending an extra __query__ parameter with the POST request,\r\n\r\n```js\r\nrequest(app)\r\n  .post('/remove/?persist=1')\r\n  .field('alias', 'name')\r\n  .expect(200)\r\n```\r\n\r\nReturns the new list of aliases as a directory listing\r\n\r\n```js\r\n{\r\n  \"name\": \"/path/\",\r\n  \"name1\": \"/path1/\",\r\n}\r\n```\r\n\r\n# Todos\r\n\r\n- ~~add range support for file streaming would be great.~~\r\n- multiple file uploads at once\r\n- change write method of the bin from POST to PUT\r\n- use POST to implement mkdir\r\n- provide built in client to consume the API\r\n- finish the tests about aliases management\r\n- make tests independent\r\n\r\n# Read more\r\n\r\n- https://github.com/andyburke/node-storehouse\r\n- http://expressjs.com/en/api.html\r\n- https://nodejs.org/api/https.html\r\n- https://github.com/expressjs/multer\r\n\r\n# Systemd\r\n\r\nTo install it as a service on systemd,\r\n\r\nEdit a file under your home such\r\n```\r\n$ ll ~/.config/systemd/user/http-file-store.service\r\n-rw-r--r-- 1 some some 340 17 mars  16:17 /home/some/.config/systemd/user/http-file-store.service\r\n```\r\n\r\nChange its content to\r\n```\r\n[Unit]\r\nDescription=Http file store\r\n\r\n[Service]\r\nExecStart=/home/some/.nvm/versions/node/v5.0.0/bin/http-file-store -c /home/some/http-file-store.json\r\nRestart=always\r\nEnvironment=PATH=/usr/bin:/usr/local/bin\r\nEnvironment=NODE_ENV=production\r\nWorkingDirectory=/some/path/wd\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n```\r\n\r\nThen use those commands to start / stop / status / enable the service\r\n```\r\nsystemctl -l --user start http-file-store.service\r\nsystemctl -l --user stop http-file-store.service\r\nsystemctl -l --user status http-file-store.service\r\nsystemctl -l --user enable http-file-store.service\r\n```\r\n\r\nTo check the logs, user\r\n```\r\njournalctl --user-unit=http-file-store\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}